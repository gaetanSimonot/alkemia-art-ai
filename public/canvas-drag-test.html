<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Canvas Pure - Drag des Boules</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
            height: 100vh;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #4a90ff;
        }

        #canvas {
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            background: rgba(0,0,0,0.1);
            cursor: grab;
        }

        #canvas:active {
            cursor: grabbing;
        }

        .controls {
            position: absolute;
            top: 80px;
            left: 20px;
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
        }

        .info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 10px;
            font-size: 12px;
        }

        button {
            background: #4a90ff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }

        button:hover {
            background: #3670d9;
        }
    </style>
</head>
<body>
    <h1>üéØ Test Canvas Pure - Drag Individuel</h1>

    <div class="controls">
        <strong>Contr√¥les:</strong><br>
        <button onclick="resetBalls()">Reset Positions</button>
        <button onclick="addRandomBall()">Ajouter Boule</button><br>
        <strong>Instructions:</strong><br>
        ‚Ä¢ Cliquez et glissez chaque boule<br>
        ‚Ä¢ Chaque boule bouge INDIVIDUELLEMENT<br>
        ‚Ä¢ Pas d'interf√©rence entre boules<br>
        ‚Ä¢ Canvas HTML5 pur - pas de librairie
    </div>

    <canvas id="canvas" width="800" height="600"></canvas>

    <div class="info" id="info">
        Clic sur une boule pour la s√©lectionner et la d√©placer
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Configuration
        let balls = [
            { id: 'work', x: 150, y: 150, radius: 40, color: '#4a90ff', emoji: 'üíº', name: 'Travail', notes: 5 },
            { id: 'personal', x: 350, y: 200, radius: 35, color: '#06d6a0', emoji: 'üè†', name: 'Personnel', notes: 3 },
            { id: 'ideas', x: 550, y: 150, radius: 45, color: '#f59e0b', emoji: 'üí°', name: 'Id√©es', notes: 7 },
            { id: 'projects', x: 200, y: 350, radius: 38, color: '#ec4899', emoji: 'üöÄ', name: 'Projets', notes: 2 },
            { id: 'family', x: 500, y: 400, radius: 30, color: '#8b5cf6', emoji: 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶', name: 'Famille', notes: 4 }
        ];

        let selectedBall = null;
        let isDragging = false;
        let mousePos = { x: 0, y: 0 };
        let dragOffset = { x: 0, y: 0 };

        // Ajuster la taille du canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth - 40;
            canvas.height = window.innerHeight - 140;
            redraw();
        }

        // Charger positions sauv√©es
        function loadPositions() {
            const saved = localStorage.getItem('canvas-ball-positions');
            if (saved) {
                const positions = JSON.parse(saved);
                balls.forEach(ball => {
                    if (positions[ball.id]) {
                        ball.x = positions[ball.id].x;
                        ball.y = positions[ball.id].y;
                    }
                });
            }
        }

        // Sauvegarder positions
        function savePositions() {
            const positions = {};
            balls.forEach(ball => {
                positions[ball.id] = { x: ball.x, y: ball.y };
            });
            localStorage.setItem('canvas-ball-positions', JSON.stringify(positions));
        }

        // Dessiner une boule
        function drawBall(ball) {
            const isSelected = selectedBall === ball;

            // Ombre
            ctx.save();
            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.shadowBlur = isSelected ? 20 : 10;
            ctx.shadowOffsetX = 5;
            ctx.shadowOffsetY = 5;

            // Cercle principal
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = ball.color;
            ctx.fill();

            // Bordure si s√©lectionn√©
            if (isSelected) {
                ctx.strokeStyle = '#06d6a0';
                ctx.lineWidth = 4;
                ctx.stroke();
            }

            ctx.restore();

            // Cercle int√©rieur avec d√©grad√©
            const gradient = ctx.createRadialGradient(
                ball.x - ball.radius/3, ball.y - ball.radius/3, 0,
                ball.x, ball.y, ball.radius
            );
            gradient.addColorStop(0, ball.color + '40');
            gradient.addColorStop(1, ball.color + '80');

            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius * 0.8, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Emoji (simul√© avec texte)
            ctx.fillStyle = 'white';
            ctx.font = `${ball.radius}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(ball.emoji, ball.x, ball.y);

            // Nom
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(ball.name, ball.x, ball.y + ball.radius + 10);

            // Compteur de notes
            const counterX = ball.x + ball.radius * 0.7;
            const counterY = ball.y - ball.radius * 0.7;

            ctx.beginPath();
            ctx.arc(counterX, counterY, 12, 0, Math.PI * 2);
            ctx.fillStyle = '#06d6a0';
            ctx.fill();

            ctx.fillStyle = 'white';
            ctx.font = 'bold 10px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(ball.notes.toString(), counterX, counterY);
        }

        // Redessiner tout
        function redraw() {
            // Effacer
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Dessiner toutes les boules
            balls.forEach(ball => drawBall(ball));
        }

        // Trouver la boule sous la souris
        function getBallAtPosition(x, y) {
            // Parcourir en ordre inverse pour prendre la boule du dessus
            for (let i = balls.length - 1; i >= 0; i--) {
                const ball = balls[i];
                const distance = Math.sqrt((x - ball.x) ** 2 + (y - ball.y) ** 2);
                if (distance <= ball.radius) {
                    return ball;
                }
            }
            return null;
        }

        // Obtenir position souris relative au canvas
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        // Event listeners
        canvas.addEventListener('mousedown', (e) => {
            mousePos = getMousePos(e);
            const ball = getBallAtPosition(mousePos.x, mousePos.y);

            if (ball) {
                selectedBall = ball;
                isDragging = true;
                dragOffset.x = mousePos.x - ball.x;
                dragOffset.y = mousePos.y - ball.y;
                canvas.style.cursor = 'grabbing';

                document.getElementById('info').textContent =
                    `S√©lectionn√©: ${ball.name} (${ball.notes} notes) - Position: (${Math.round(ball.x)}, ${Math.round(ball.y)})`;

                console.log(`Selected ball: ${ball.id}`);
            } else {
                selectedBall = null;
            }

            redraw();
        });

        canvas.addEventListener('mousemove', (e) => {
            mousePos = getMousePos(e);

            if (isDragging && selectedBall) {
                // Calculer nouvelle position
                const newX = mousePos.x - dragOffset.x;
                const newY = mousePos.y - dragOffset.y;

                // Contraintes pour rester dans le canvas
                selectedBall.x = Math.max(selectedBall.radius,
                    Math.min(newX, canvas.width - selectedBall.radius));
                selectedBall.y = Math.max(selectedBall.radius,
                    Math.min(newY, canvas.height - selectedBall.radius));

                document.getElementById('info').textContent =
                    `D√©placement: ${selectedBall.name} - Position: (${Math.round(selectedBall.x)}, ${Math.round(selectedBall.y)})`;

                redraw();
            } else {
                // Changer curseur selon ce qui est sous la souris
                const ball = getBallAtPosition(mousePos.x, mousePos.y);
                canvas.style.cursor = ball ? 'grab' : 'default';
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (isDragging && selectedBall) {
                console.log(`Moved ball ${selectedBall.id} to (${selectedBall.x}, ${selectedBall.y})`);
                savePositions();
            }

            isDragging = false;
            canvas.style.cursor = 'default';
        });

        // Fonctions utilitaires
        function resetBalls() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(canvas.width, canvas.height) * 0.3;

            balls.forEach((ball, index) => {
                const angle = (index * 2 * Math.PI) / balls.length;
                ball.x = centerX + Math.cos(angle) * radius;
                ball.y = centerY + Math.sin(angle) * radius;
            });

            localStorage.removeItem('canvas-ball-positions');
            selectedBall = null;
            redraw();
            console.log('Balls reset to default positions');
        }

        function addRandomBall() {
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57'];
            const emojis = ['‚≠ê', 'üéØ', 'üî•', 'üí´', 'üåü', '‚ú®'];
            const names = ['Nouveau', 'Test', 'Demo', 'Extra', 'Bonus'];

            const newBall = {
                id: 'ball_' + Date.now(),
                x: Math.random() * (canvas.width - 100) + 50,
                y: Math.random() * (canvas.height - 100) + 50,
                radius: 30 + Math.random() * 20,
                color: colors[Math.floor(Math.random() * colors.length)],
                emoji: emojis[Math.floor(Math.random() * emojis.length)],
                name: names[Math.floor(Math.random() * names.length)],
                notes: Math.floor(Math.random() * 10) + 1
            };

            balls.push(newBall);
            redraw();
            console.log('Added new ball:', newBall.id);
        }

        // Initialisation
        function init() {
            resizeCanvas();
            loadPositions();
            redraw();
            console.log('Canvas ball test initialized');
        }

        // D√©marrer
        window.addEventListener('load', init);
        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>